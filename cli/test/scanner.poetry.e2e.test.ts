import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { existsSync, readFileSync, statSync } from 'node:fs';
import { execFile } from 'node:child_process';

vi.mock('node:fs');
vi.mock('node:child_process');

describe('scanner e2e - Poetry', () => {
  let createCli: any;
  const originalFetch = global.fetch as any;
  const origLog = console.log;
  let logs: string[] = [];

  function mockOsvResponse(vulns: any[] = []) {
    return { ok: true, json: async () => ({ vulns }) } as any;
  }

  const mockPyprojectToml = `[tool.poetry]
name = "test-project"
version = "0.1.0"

[tool.poetry.dependencies]
python = "^3.9"
requests = "^2.28.0"
`;

  const mockPoetryLock = `# This file is automatically @generated by Poetry and should not be changed by hand.

[[package]]
name = "requests"
version = "2.28.1"
category = "main"
optional = false
python-versions = ">=3.7, <4"
`;

  beforeEach(async () => {
    logs = [];
    console.log = (...args: any[]) => logs.push(args.join(' '));

    // Mock file system for Poetry project
    vi.mocked(existsSync).mockImplementation((p: any) => {
      const path = String(p);
      if (path.endsWith('pyproject.toml')) return true;
      if (path.endsWith('poetry.lock')) return true;
      if (path.endsWith('package.json')) return false;
      return false;
    });

    vi.mocked(statSync).mockImplementation((p: any) => {
      const path = String(p);
      // Return a directory stat for '.'
      if (path === '.' || path.endsWith('/')) {
        return {
          isFile: () => false,
          isDirectory: () => true,
        } as any;
      }
      // Return a file stat for specific files
      if (path.endsWith('pyproject.toml') || path.endsWith('poetry.lock')) {
        return {
          isFile: () => true,
          isDirectory: () => false,
        } as any;
      }
      // Default to directory
      return {
        isFile: () => false,
        isDirectory: () => true,
      } as any;
    });

    vi.mocked(readFileSync).mockImplementation((p: any) => {
      const path = String(p);
      if (path.endsWith('pyproject.toml')) {
        return mockPyprojectToml;
      }
      if (path.endsWith('poetry.lock')) {
        return mockPoetryLock;
      }
      return '';
    });

    // Mock execFile to work with promisify
    vi.mocked(execFile).mockImplementation((cmd: any, args: any, opts: any, cb?: any) => {
      const callback = typeof opts === 'function' ? opts : cb;
      if (callback) {
        setImmediate(() => callback(null, { stdout: '', stderr: '' }));
      }
      return {} as any;
    });

    // Mock OSV API with Python vulnerability
    global.fetch = vi.fn().mockResolvedValue(
      mockOsvResponse([
        {
          id: 'PYSEC-2023-123',
          affected: [
            {
              package: { ecosystem: 'PyPI', name: 'requests' },
              versions: ['2.28.1'],
            },
          ],
          database_specific: { severity: 'HIGH' },
        },
      ]),
    );

    ({ createCli } = await import('../src/index.ts'));
  }, 30000); // 30 second timeout

  afterEach(() => {
    console.log = origLog;
    global.fetch = originalFetch;
    vi.resetModules();
    vi.clearAllMocks();
  });

  it('scans Poetry project and prints results', async () => {
    const y = createCli(['.']);
    await y.parseAsync();

    const out = logs.join('\n');
    // Check for the vulnerability results
    expect(out).toMatch(/PYSEC-2023-123/);
    expect(out).toMatch(/requests/);
    expect(out).toMatch(/HIGH/);
  });

  it('validates Poetry lockfile when --lockfile check is used', async () => {
    const y = createCli(['.', '--lockfile', 'check']);

    // This test verifies that the scanner runs with lockfile check mode
    // The actual poetry validation would happen in a real environment
    await y.parseAsync();

    // We can verify the scan completed successfully by checking logs
    const out = logs.join('\n');
    expect(out).toMatch(/PYSEC-2023-123/); // Should show vulnerability results
  });

  it('queries OSV with PyPI ecosystem', async () => {
    const y = createCli(['.']);
    await y.parseAsync();

    expect(global.fetch).toHaveBeenCalledWith(
      'https://api.osv.dev/v1/query',
      expect.objectContaining({
        body: expect.stringContaining('"ecosystem":"PyPI"'),
      }),
    );
  });
});
