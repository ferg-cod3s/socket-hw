import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';

// Hoist mocks before imports
const mockExecFile = vi.hoisted(() => vi.fn());
const mockExistsSync = vi.hoisted(() => vi.fn());
const mockReadFileSync = vi.hoisted(() => vi.fn());

vi.mock('node:fs', () => ({
  existsSync: mockExistsSync,
  readFileSync: mockReadFileSync,
}));

vi.mock('node:child_process', () => ({
  execFile: mockExecFile,
}));

describe('PythonPoetryProvider', () => {
  let PythonPoetryProvider: any;
  let provider: any;

  const mockPyprojectToml = `[tool.poetry]
name = "test-project"
version = "0.1.0"

[tool.poetry.dependencies]
python = "^3.9"
requests = "^2.28.0"
pydantic = {version = "^1.10.0", extras = ["email"]}

[tool.poetry.group.dev.dependencies]
pytest = "^7.0.0"
`;

  const mockPoetryLock = `# This file is automatically @generated by Poetry and should not be changed by hand.

[[package]]
name = "requests"
version = "2.28.1"
category = "main"
optional = false
python-versions = ">=3.7, <4"

[[package]]
name = "pydantic"
version = "1.10.2"
category = "main"
optional = false
python-versions = ">=3.7"

[[package]]
name = "pytest"
version = "7.1.0"
category = "dev"
optional = false
python-versions = ">=3.7"
`;

  beforeEach(async () => {
    vi.resetModules();
    mockExecFile.mockClear();
    mockExistsSync.mockClear();
    mockReadFileSync.mockClear();

    ({ PythonPoetryProvider } = await import(
      '../../src/providers/python-poetry/index.js'
    ));
    provider = new PythonPoetryProvider();
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe('detect', () => {
    it('returns null when pyproject.toml does not exist', () => {
      mockExistsSync.mockReturnValue(false);
      expect(provider.detect('/test/project')).toBeNull();
    });

    it('detects Poetry project from pyproject.toml', () => {
      mockExistsSync.mockReturnValue(true);
      mockReadFileSync.mockReturnValue(mockPyprojectToml);

      const result = provider.detect('/test/project');
      expect(result).not.toBeNull();
      expect(result.providerId).toBe('python-poetry');
      expect(result.name).toBe('Poetry');
      expect(result.confidence).toBe(1.0);
    });

    it('returns null for non-Poetry pyproject.toml', () => {
      mockExistsSync.mockReturnValue(true);
      mockReadFileSync.mockReturnValue(`[build-system]
requires = ["setuptools"]
`);

      expect(provider.detect('/test/project')).toBeNull();
    });
  });

  describe('ensureLockfile', () => {
    beforeEach(() => {
      // Mock execFile to work with promisify
      mockExecFile.mockImplementation((cmd: any, args: any, opts: any, cb?: any) => {
        const callback = typeof opts === 'function' ? opts : cb;
        if (callback) {
          setImmediate(() => callback(null, { stdout: '', stderr: '' }));
        }
        return {} as any;
      });
    });

    it('creates lockfile when missing and createIfMissing is true', async () => {
      mockExistsSync.mockReturnValue(false);

      await provider.ensureLockfile('/test/project', {
        createIfMissing: true,
      });

      expect(mockExecFile).toHaveBeenCalled();
      const calls = mockExecFile.mock.calls;
      expect(calls[0][0]).toBe('poetry');
      expect(calls[0][1]).toEqual(['lock', '--no-update']);
      expect(calls[0][2]).toMatchObject({ cwd: '/test/project' });
    });

    it('validates lockfile when present and validateIfPresent is true', async () => {
      mockExistsSync.mockReturnValue(true);

      await provider.ensureLockfile('/test/project', {
        validateIfPresent: true,
      });

      expect(mockExecFile).toHaveBeenCalled();
      const calls = mockExecFile.mock.calls;
      expect(calls[0][0]).toBe('poetry');
      expect(calls[0][1]).toEqual(['check', '--lock']);
      expect(calls[0][2]).toMatchObject({ cwd: '/test/project' });
    });

    it('forces refresh when forceRefresh is true', async () => {
      mockExistsSync.mockReturnValue(true);

      await provider.ensureLockfile('/test/project', {
        forceRefresh: true,
      });

      expect(mockExecFile).toHaveBeenCalled();
      const calls = mockExecFile.mock.calls;
      expect(calls[0][0]).toBe('poetry');
      expect(calls[0][1]).toEqual(['lock', '--no-update']);
      expect(calls[0][2]).toMatchObject({ cwd: '/test/project' });
    });

    it('forces validation when forceValidate is true', async () => {
      mockExistsSync.mockReturnValue(true);

      await provider.ensureLockfile('/test/project', {
        forceValidate: true,
      });

      expect(mockExecFile).toHaveBeenCalled();
      const calls = mockExecFile.mock.calls;
      expect(calls[0][0]).toBe('poetry');
      expect(calls[0][1]).toEqual(['check', '--lock']);
      expect(calls[0][2]).toMatchObject({ cwd: '/test/project' });
    });
  });

  describe('gatherDependencies', () => {
    it('parses lockfile when present', async () => {
      mockExistsSync.mockImplementation((p: any) => {
        return String(p).endsWith('poetry.lock');
      });
      mockReadFileSync.mockReturnValue(mockPoetryLock);

      const deps = await provider.gatherDependencies('/test/project', {});

      expect(deps).toHaveLength(2);
      expect(deps).toContainEqual({
        name: 'requests',
        version: '2.28.1',
        ecosystem: 'PyPI',
      });
      expect(deps).toContainEqual({
        name: 'pydantic',
        version: '1.10.2',
        ecosystem: 'PyPI',
      });
      // pytest is dev, should be excluded
    });

    it('includes dev dependencies from lockfile when includeDev is true', async () => {
      mockExistsSync.mockImplementation((p: any) => {
        return String(p).endsWith('poetry.lock');
      });
      mockReadFileSync.mockReturnValue(mockPoetryLock);

      const deps = await provider.gatherDependencies('/test/project', {
        includeDev: true,
      });

      expect(deps).toHaveLength(3);
      expect(deps).toContainEqual({
        name: 'pytest',
        version: '7.1.0',
        ecosystem: 'PyPI',
      });
    });

    it('falls back to pyproject.toml when lockfile missing', async () => {
      mockExistsSync.mockImplementation((p: any) => {
        return String(p).endsWith('pyproject.toml');
      });
      mockReadFileSync.mockReturnValue(mockPyprojectToml);

      const deps = await provider.gatherDependencies('/test/project', {});

      expect(deps).toHaveLength(2);
      expect(deps).toContainEqual({
        name: 'requests',
        version: '^2.28.0',
        ecosystem: 'PyPI',
      });
      expect(deps).toContainEqual({
        name: 'pydantic',
        version: '^1.10.0',
        ecosystem: 'PyPI',
      });
      // python itself is excluded
    });

    it('includes dev dependencies from pyproject.toml when includeDev is true', async () => {
      mockExistsSync.mockImplementation((p: any) => {
        return String(p).endsWith('pyproject.toml');
      });
      mockReadFileSync.mockReturnValue(mockPyprojectToml);

      const deps = await provider.gatherDependencies('/test/project', {
        includeDev: true,
      });

      expect(deps.length).toBeGreaterThanOrEqual(3);
      expect(deps.some((d) => d.name === 'pytest')).toBe(true);
    });
  });
});

